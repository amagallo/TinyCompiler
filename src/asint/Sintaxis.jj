options
{
  STATIC = false;
  IGNORE_CASE = true;
  CACHE_TOKENS = true;
  OUTPUT_DIRECTORY = "../procesamientos";
}

PARSER_BEGIN(AnalizadorSintactico)

package procesamientos;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import static asint.Sintaxis.*;

@SuppressWarnings({ "rawtypes", "unused", "unchecked" })
public class AnalizadorSintactico extends Procesamiento {}

PARSER_END(AnalizadorSintactico)

SKIP:
{
  <separador: ["\b", "\n", "\r"]>
  | <blanco: " ">
  | <comentario: "@" (~["\n"])* ["\n"]>
}

TOKEN:
{
  <var: "var">   
  | <tipo: "type"> 
  | <proc: "proc">

  | <tipoBasico: "int" | "bool" | "real" | "string">
  | <of: "of">
  | <array: "array"> 
  | <registro: "record"> 
  | <puntero: "^"> 

  | <asignacion: "="> 
  | <ifSimbolo: "if"> 
  | <then: "then">
  | <elseSimbolo: "else"> 
  | <whileSimbolo: "while"> 
  | <doSimbolo: "do"> 
  | <read: "read">
  | <write: "write">
  | <nl: "nl"> 
  | <newSimbolo: "new"> 
  | <delete: "delete"> 
  | <seq: "seq"> 
  | <begin: "begin"> 
  | <end: "end">

  | <booleano: "true" | "false">
  | <nulo: "null">
}

TOKEN:
{
  <opRelacional: "==" | "!=" | "<=" | ">=" | "<" | ">">

  | <suma: "+">
  | <resta: "-">
  | <mul: "*">
  | <div: "/">
  | <mod: "%">

  | <and: "and">
  | <or: "or">
  | <not: "not">
}

TOKEN:
{
  <parentesisApertura: "(">
  | <parentesisCierre: ")"> 
  | <corcheteApertura: "[">
  | <corcheteCierre: "]">   
  | <puntoComa: ";">
  | <coma: ",">
  | <dosPuntos: ":">
  | <punto: ".">
}

TOKEN:
{
  <#letra: ["a"-"z"] | ["A"-"Z"]>
  | <#digitoPositivo: ["1"-"9"]>
  | <#digito: <digitoPositivo> | "0">
  | <entero: (["+", "-"])? ("0" | <digitoPositivo> (<digito>)*)>
  | <real: <entero> (<decimal> | <exponencial> | <decimal> <exponencial>)?>
  | <#decimal: "." ("0" | (<digito>)* <digitoPositivo>)>
  | <#exponencial: ["e", "E"] <entero>>
  | <identificador: <letra> (<letra> | <digito> | "_")*>
  | <cadena: "'" (<caracterImprimible>)* "'">
  | <#caracterImprimible: ~["'", "\b", "\r", "\n"]>
}

Prog Prog(): { List<Dec> ldec; List<Ins> lins; }
{
  ldec=SeccionDecs() lins=SeccionIns() <punto> <EOF>
  {
    return new Prog(ldec, lins, new Nodo(1, 1));
  }
}
    
List<Dec> SeccionDecs(): { List<Dec> ldec = new ArrayList<Dec>(); Dec dec; }
{
  (dec=Dec() { ldec.add(dec); } <puntoComa>)*

  { return Collections.unmodifiableList(ldec); }
}

List<Ins> SeccionIns(): { List<Ins> lins = new ArrayList<Ins>(); Ins ins; }
{
  <begin> (ins=Ins() { lins.add(ins); })* <end>

  { return Collections.unmodifiableList(lins); }
}

Dec Dec(): { Dec dec; }
{
  dec=DecVar()
  { return dec; }
  | dec=DecTipo()
  { return dec; }
  | dec=DecProc()
  { return dec; }
}

Dec DecVar(): { Token id; Tipo tipo; }
{
  <var> id=<identificador> <dosPuntos> tipo=Tipo()
  {
    return new Var(id.image, tipo, new Nodo(id.beginLine, id.beginColumn));
  }
}

Dec DecTipo(): { Token id; Tipo t; }
{
  <tipo> id=<identificador> <dosPuntos> t=Tipo()
  {
    return new Type(id.image, t, new Nodo(id.beginLine, id.beginColumn));
  }
}

Dec DecProc(): { Token id; List<Param> param; List<Dec> ldec; List<Ins> lins; }
{
  <proc> id=<identificador> <parentesisApertura> param=PFormales() <parentesisCierre>
  ldec=SeccionDecs() lins=SeccionIns()
  {
    return new Proc(id.image, param, ldec, lins, new Nodo(id.beginLine, id.beginColumn));
  }
}

List<Param> PFormales(): { List<Param> lparam = new ArrayList<Param>(); Param param; }
{
  [param=PFormal() { lparam.add(param); }
  (<coma> param=PFormal() { lparam.add(param); })*]

  { return Collections.unmodifiableList(lparam); }
}

Param PFormal(): { Token v = null; Token id; Tipo tipo; }
{
  [v=<var>] id=<identificador> <dosPuntos> tipo=Tipo()
  {
    Nodo nodo = new Nodo(id.beginLine, id.beginColumn);
    return (v == null)? new Pval(id.image, tipo, nodo): new Pvar(id.image, tipo, nodo);
  }
}

Tipo Tipo(): { Token basico; Tipo tipo; }
{
  basico=<tipoBasico>
  {
    String str = basico.image;
    Nodo nodo = new Nodo(basico.beginLine, basico.beginColumn);

    if (str.equals("int"))
      return new Int(nodo);
    else if (str.equals("real"))
      return new Real(nodo);
    else if (str.equals("bool"))
      return new Bool(nodo);
    else if (str.equals("string"))
      return new Str(nodo);
  }
  | tipo=TipoRenombrado()
  { return tipo; }
  | tipo=TipoArray()
  { return tipo; }
  | tipo=TipoRegistro()
  { return tipo; }
  | tipo=TipoPuntero()
  { return tipo; }
}

Tipo TipoRenombrado(): { Token id; }
{
  id=<identificador>
  {
    return new Ref(id.image, new Nodo(id.beginLine, id.beginColumn));
  }
}

Tipo TipoArray(): { Token a; Token tam; Tipo tipo; }
{
  a=<array> <corcheteApertura> tam=<entero> <corcheteCierre> <of> tipo=Tipo()
  {
    return new Array(tipo, tam.image, new Nodo(a.beginLine, a.beginColumn));
  }
}

Tipo TipoPuntero(): { Token punt; Tipo base; }
{
  punt=<puntero> base=Tipo()
  {
    return new Puntero(base, new Nodo(punt.beginLine, punt.beginColumn));
  }
}

Tipo TipoRegistro(): { Token reg; List<Campo> lcampo = new ArrayList<Campo>(); Campo campo; }
{
  reg=<registro> (campo=Campo() { lcampo.add(campo); })+ <end>

  { return new Reg(Collections.unmodifiableList(lcampo), new Nodo(reg.beginLine, reg.beginColumn)); }
}

Campo Campo(): { Token id; Tipo tipo; }
{
  id=<identificador> <dosPuntos> tipo=Tipo() <puntoComa>
  
  { return new Campo(id.image, tipo, new Nodo(id.beginLine, id.beginColumn)); }
}

Ins Ins(): { Ins ins; }
{
  ins=Ident()
  { return ins; }
  | ins=Condicional()
  { return ins; }
  | ins=While()
  { return ins; }
  { return ins; }
  | ins=Lectura()
  { return ins; }
  | ins=Escritura()
  { return ins; }
  | ins=NewLine()
  { return ins; }
  | ins=New()
  { return ins; }
  | ins=Delete()
  { return ins; }
  | ins=Compuesta()
  { return ins; }
}

Ins Ident(): { Exp eid; Ins ins; }
{
  eid=Expresion() ins=InsExp(eid)
  { return ins; }
}

Ins InsExp(Exp eid): { Ins ins; }
{
  ins=Asig(eid)
  { return ins; }
  | ins=Invoc(eid)
  { return ins; }
}

Ins Asig(Exp ei): { Token asig; Exp ed; }
{
  asig=<asignacion> ed=Expresion() <puntoComa>
  {
    return new Asig(ei, ed, new Nodo(asig.beginLine, asig.beginColumn));
  }
}

Ins Invoc(Exp eid): { Token parentesis; List<Exp> preal; }
{
  parentesis=<parentesisApertura> preal=PReales() <parentesisCierre> <puntoComa>
  {
    return new Invoc(eid, preal, new Nodo(parentesis.beginLine, parentesis.beginColumn));
  }
}

Ins Condicional():
{ Token cond; Exp exp; Token e = null; Ins ins; List<Ins> lins = new ArrayList<Ins>(), lins2 = new ArrayList<Ins>(); }
{
  cond=<ifSimbolo> exp=Expresion() <then> (ins=Ins() { lins.add(ins); })*
  [e=<elseSimbolo> (ins=Ins() { lins2.add(ins); })*] <end> [<puntoComa>]
  {
    List<Ins> linsInmutable = Collections.unmodifiableList(lins);
    Nodo nodo = new Nodo(cond.beginLine, cond.beginColumn);
    
    return (e == null)? new IfThen(exp, linsInmutable, nodo):
      new IfThenElse(exp, linsInmutable, Collections.unmodifiableList(lins2), nodo);
  }
}

Ins While(): { Token wh; Exp exp; List<Ins> lins = new ArrayList<Ins>(); Ins ins; }
{
  wh=<whileSimbolo> exp=Expresion() <doSimbolo> (ins=Ins() { lins.add(ins); })* <end> [<puntoComa>]
  {
    Nodo nodo = new Nodo(wh.beginLine, wh.beginColumn);
    return new While(exp, Collections.unmodifiableList(lins), nodo);
  }
}

Ins Compuesta(): { Token s; List<Dec> ldec = new ArrayList<Dec>(); List<Ins> lins = new ArrayList<Ins>(); }
{
  s=<seq> ldec=SeccionDecs() lins=SeccionIns() [<puntoComa>]
  {
    return new Seq(ldec, lins, new Nodo(s.beginLine, s.beginColumn));
  }
}

Ins Lectura(): { Token r; Exp exp; }
{
  r=<read> exp=Expresion() <puntoComa> 
  {
    return new Read(exp, new Nodo(r.beginLine, r.beginColumn));
  }
}

Ins Escritura(): { Token w; Exp exp; }
{
  w=<write> exp=Expresion() <puntoComa>
  {
    return new Write(exp, new Nodo(w.beginLine, w.beginColumn));
  }
}

Ins NewLine(): { Token n; } { n=<nl> <puntoComa> { return new NewLine(new Nodo(n.beginLine, n.beginColumn)); } }

Ins New(): { Token n; Exp exp; }
{
  n=<newSimbolo> exp=Expresion() <puntoComa>
  {
    return new New(exp, new Nodo(n.beginLine, n.beginColumn));
  }
}

Ins Delete(): { Token d; Exp exp; }
{
  d=<delete> exp=Expresion() <puntoComa>
  {
    return new Delete(exp, new Nodo(d.beginLine, d.beginColumn));
  }
}

List<Exp> PReales(): { List<Exp> lexp = new ArrayList<Exp>(); Exp preal; }
{
  [preal=PReal() { lexp.add(preal); } (<coma> preal=PReal() { lexp.add(preal); })*]

  { return Collections.unmodifiableList(lexp); }
}

Exp PReal(): { Exp exp; } { exp=Expresion() { return exp; } }

Exp Expresion(): { Exp exp; } { exp=ExpNivel0() { return exp; } }

Exp ExpNivel0(): { Exp exp; }
{
  exp=ExpNivel1() [exp=OpNivel0(exp)]
  { return exp; }
}

Exp OpNivel0(Exp op1): { Exp op2; Token op; }
{
  op=<opRelacional> op2=ExpNivel1()
  {
    Nodo nodo = new Nodo(op.beginLine, op.beginColumn);

    String str = op.image;
    if (str.equals("=="))
      return new Eq(op1, op2, nodo);
    else if (str.equals("!="))
      return new Ne(op1, op2, nodo);
    else if (str.equals("<="))  
      return new Le(op1, op2, nodo);
    else if (str.equals(">="))
      return new Ge(op1, op2, nodo);
    else if (str.equals("<"))
      return new Lt(op1, op2, nodo);
    else if (str.equals(">")) 
      return new Gt(op1, op2, nodo);
  }
}

Exp ExpNivel1(): { Exp op1; Token op; Exp op2; }
{
  op1=Suma() (op=<resta> op2=ExpNivel2()
  { op1 = new Resta(op1, op2, new Nodo(op.beginLine, op.beginColumn)); return op1; })*

  { return op1; }
}

Exp Suma(): { Exp op1; Token op = null; Exp op2 = null; }
{
  op1=ExpNivel2() [op=<suma> op2=ExpNivel2()]
  { return (op == null)? op1: new Suma(op1, op2, new Nodo(op.beginLine, op.beginColumn)); }
}

Exp ExpNivel2(): { Exp exp; }
{
  exp=ExpNivel3() (exp=OpNivel2(exp))?
  { return exp; }
} 

Exp OpNivel2(Exp op1): { Exp exp; }
{
  exp=And(op1)
  { return exp; }
  | exp=Or(op1)
  { return exp; }
}

Exp And(Exp op1): { Token op; Exp op2; }
{
  op=<and> op2=ExpNivel3()
  
  { return new And(op1, op2, new Nodo(op.beginLine, op.beginColumn)); }
}

Exp Or(Exp op1): { Token op; Exp op2; }
{
  op=<or> op2=ExpNivel2()

  { return new Or(op1, op2, new Nodo(op.beginLine, op.beginColumn)); }
}

Exp ExpNivel3(): { Exp exp; }
{
  exp=ExpNivel4() (exp=ExpBinaria3(exp))*

  { return exp; }
}

Exp ExpBinaria3(Exp op1): { Token op; Exp op2; }
{
  op=<mul> op2=ExpNivel4()
  { return op1 = new Mul(op1, op2, new Nodo(op.beginLine, op.beginColumn)); }
  | op=<div> op2=ExpNivel4()
  { return op1 = new Div(op1, op2, new Nodo(op.beginLine, op.beginColumn)); }
  | op=<mod> op2=ExpNivel4()
  { return op1 = new Mod(op1, op2, new Nodo(op.beginLine, op.beginColumn)); }

  { return op1; }
}

Exp ExpNivel4(): { Exp exp; }
{
  exp=ExpUnaria4()
  { return exp; }
  | exp=ExpNivel5()
  { return exp; }
}

Exp ExpUnaria4(): { Token op; Exp op1; }
{
  op=<resta> op1=ExpNivel4()
  { return new Neg(op1, new Nodo(op.beginLine, op.beginColumn)); }
  | op=<not> op1=ExpNivel4()
  { return new Not(op1, new Nodo(op.beginLine, op.beginColumn)); }
}

Exp ExpNivel5(): { Exp exp; }
{
  exp=ExpNoPosfija() (exp=ExpPosfija(exp))*
  { return exp; }
}

Exp ExpPosfija(Exp base): { Exp exp; }
{
  exp=Indx(base)
  { return exp; }
  | exp=Acc(base)
  { return exp; }
  | exp=Indir(base)
  { return exp; }
}

Exp ExpNoPosfija(): { Exp exp; }
{
  exp=ExpParentizada()
  { return exp; }
  | exp=ExpBasica()
  { return exp; }
}

Exp ExpParentizada(): { Exp exp; }
{
  <parentesisApertura> exp=ExpNivel0() <parentesisCierre>
  { return exp; }
}

Exp ExpBasica(): { Token lit; String str; }
{ lit=<entero> { return new Entero(lit.image, new Nodo(lit.beginLine, lit.beginColumn)); }
  | lit=<real> { return new Decimal(lit.image, new Nodo(lit.beginLine, lit.beginColumn)); }
  | lit=<cadena>
  {
    str = lit.image;
    return new Cadena(str.substring(1, str.length() - 1), new Nodo(lit.beginLine, lit.beginColumn));
  }
  | lit=<identificador> { return new Ident(lit.image, new Nodo(lit.beginLine, lit.beginColumn)); }
  | lit=<booleano>
  {
    str = lit.image;
    Nodo nodo = new Nodo(lit.beginLine, lit.beginColumn);
    
    if (str.equals("true"))
      return new True(nodo);
    else if (str.equals("false"))
      return new False(nodo);
  }
  | lit=<nulo> { return new Nulo(new Nodo(lit.beginLine, lit.beginColumn)); }
}

Exp Indx(Exp ei): { Token corchete; Exp eid; }
{
  corchete=<corcheteApertura> eid=Expresion() <corcheteCierre>
  { return new Indx(ei, eid, new Nodo(corchete.beginLine, corchete.beginColumn)); }
}

Exp Acc(Exp reg): { Token op; Token id; }
{
  op=<punto> id=<identificador>
  { return new Acc(reg, id.image, new Nodo(op.beginLine, op.beginColumn)); }
}

Exp Indir(Exp et): { Token op; }
{
  op=<puntero>
  { return new Indir(et, new Nodo(op.beginLine, op.beginColumn)); }
}