/* Generated By:JavaCC: Do not edit this line. AnalizadorSintactico.java */
package procesamientos;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import static asint.Sintaxis.*;

@SuppressWarnings({ "rawtypes", "unused", "unchecked" })
public class AnalizadorSintactico extends Procesamiento implements AnalizadorSintacticoConstants {

  final public Prog Prog() throws ParseException {
               List<Dec> ldec; List<Ins> lins;
    ldec = SeccionDecs();
    lins = SeccionIns();
    jj_consume_token(punto);
    jj_consume_token(0);
    {if (true) return new Prog(ldec, lins, new Nodo(1, 1));}
    throw new Error("Missing return statement in function");
  }

  final public List<Dec> SeccionDecs() throws ParseException {
                           List<Dec> ldec = new ArrayList<Dec>(); Dec dec;
    label_1:
    while (true) {
      switch (jj_nt.kind) {
      case var:
      case tipo:
      case proc:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      dec = Dec();
               ldec.add(dec);
      jj_consume_token(puntoComa);
    }
    {if (true) return Collections.unmodifiableList(ldec);}
    throw new Error("Missing return statement in function");
  }

  final public List<Ins> SeccionIns() throws ParseException {
                          List<Ins> lins = new ArrayList<Ins>(); Ins ins;
    jj_consume_token(begin);
    label_2:
    while (true) {
      switch (jj_nt.kind) {
      case ifSimbolo:
      case whileSimbolo:
      case read:
      case write:
      case nl:
      case newSimbolo:
      case delete:
      case seq:
      case booleano:
      case nulo:
      case resta:
      case not:
      case parentesisApertura:
      case entero:
      case real:
      case identificador:
      case cadena:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      ins = Ins();
                       lins.add(ins);
    }
    jj_consume_token(end);
    {if (true) return Collections.unmodifiableList(lins);}
    throw new Error("Missing return statement in function");
  }

  final public Dec Dec() throws ParseException {
             Dec dec;
    switch (jj_nt.kind) {
    case var:
      dec = DecVar();
    {if (true) return dec;}
      break;
    case tipo:
      dec = DecTipo();
    {if (true) return dec;}
      break;
    case proc:
      dec = DecProc();
    {if (true) return dec;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Dec DecVar() throws ParseException {
                Token id; Tipo tipo;
    jj_consume_token(var);
    id = jj_consume_token(identificador);
    jj_consume_token(dosPuntos);
    tipo = Tipo();
    {if (true) return new Var(id.image, tipo, new Nodo(id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Dec DecTipo() throws ParseException {
                 Token id; Tipo t;
    jj_consume_token(tipo);
    id = jj_consume_token(identificador);
    jj_consume_token(dosPuntos);
    t = Tipo();
    {if (true) return new Type(id.image, t, new Nodo(id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Dec DecProc() throws ParseException {
                 Token id; List<Param> param; List<Dec> ldec; List<Ins> lins;
    jj_consume_token(proc);
    id = jj_consume_token(identificador);
    jj_consume_token(parentesisApertura);
    param = PFormales();
    jj_consume_token(parentesisCierre);
    ldec = SeccionDecs();
    lins = SeccionIns();
    {if (true) return new Proc(id.image, param, ldec, lins, new Nodo(id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public List<Param> PFormales() throws ParseException {
                           List<Param> lparam = new ArrayList<Param>(); Param param;
    switch (jj_nt.kind) {
    case var:
    case identificador:
      param = PFormal();
                     lparam.add(param);
      label_3:
      while (true) {
        switch (jj_nt.kind) {
        case coma:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_3;
        }
        jj_consume_token(coma);
        param = PFormal();
                            lparam.add(param);
      }
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    {if (true) return Collections.unmodifiableList(lparam);}
    throw new Error("Missing return statement in function");
  }

  final public Param PFormal() throws ParseException {
                   Token v = null; Token id; Tipo tipo;
    switch (jj_nt.kind) {
    case var:
      v = jj_consume_token(var);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    id = jj_consume_token(identificador);
    jj_consume_token(dosPuntos);
    tipo = Tipo();
    Nodo nodo = new Nodo(id.beginLine, id.beginColumn);
    {if (true) return (v == null)? new Pval(id.image, tipo, nodo): new Pvar(id.image, tipo, nodo);}
    throw new Error("Missing return statement in function");
  }

  final public Tipo Tipo() throws ParseException {
               Token basico; Tipo tipo;
    switch (jj_nt.kind) {
    case tipoBasico:
      basico = jj_consume_token(tipoBasico);
    String str = basico.image;
    Nodo nodo = new Nodo(basico.beginLine, basico.beginColumn);

    if (str.equals("int"))
      {if (true) return new Int(nodo);}
    else if (str.equals("real"))
      {if (true) return new Real(nodo);}
    else if (str.equals("bool"))
      {if (true) return new Bool(nodo);}
    else if (str.equals("string"))
      {if (true) return new Str(nodo);}
      break;
    case identificador:
      tipo = TipoRenombrado();
    {if (true) return tipo;}
      break;
    case array:
      tipo = TipoArray();
    {if (true) return tipo;}
      break;
    case registro:
      tipo = TipoRegistro();
    {if (true) return tipo;}
      break;
    case puntero:
      tipo = TipoPuntero();
    {if (true) return tipo;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Tipo TipoRenombrado() throws ParseException {
                         Token id;
    id = jj_consume_token(identificador);
    {if (true) return new Ref(id.image, new Nodo(id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Tipo TipoArray() throws ParseException {
                    Token a; Token tam; Tipo tipo;
    a = jj_consume_token(array);
    jj_consume_token(corcheteApertura);
    tam = jj_consume_token(entero);
    jj_consume_token(corcheteCierre);
    jj_consume_token(of);
    tipo = Tipo();
    {if (true) return new Array(tipo, tam.image, new Nodo(a.beginLine, a.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Tipo TipoPuntero() throws ParseException {
                      Token punt; Tipo base;
    punt = jj_consume_token(puntero);
    base = Tipo();
    {if (true) return new Puntero(base, new Nodo(punt.beginLine, punt.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Tipo TipoRegistro() throws ParseException {
                       Token reg; List<Campo> lcampo = new ArrayList<Campo>(); Campo campo;
    reg = jj_consume_token(registro);
    label_4:
    while (true) {
      campo = Campo();
                                  lcampo.add(campo);
      switch (jj_nt.kind) {
      case identificador:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
    }
    jj_consume_token(end);
    {if (true) return new Reg(Collections.unmodifiableList(lcampo), new Nodo(reg.beginLine, reg.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Campo Campo() throws ParseException {
                 Token id; Tipo tipo;
    id = jj_consume_token(identificador);
    jj_consume_token(dosPuntos);
    tipo = Tipo();
    jj_consume_token(puntoComa);
    {if (true) return new Campo(id.image, tipo, new Nodo(id.beginLine, id.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Ins Ins() throws ParseException {
             Ins ins;
    switch (jj_nt.kind) {
    case booleano:
    case nulo:
    case resta:
    case not:
    case parentesisApertura:
    case entero:
    case real:
    case identificador:
    case cadena:
      ins = Ident();
    {if (true) return ins;}
      break;
    case ifSimbolo:
      ins = Condicional();
    {if (true) return ins;}
      break;
    case whileSimbolo:
      ins = While();
    {if (true) return ins;}
    {if (true) return ins;}
      break;
    case read:
      ins = Lectura();
    {if (true) return ins;}
      break;
    case write:
      ins = Escritura();
    {if (true) return ins;}
      break;
    case nl:
      ins = NewLine();
    {if (true) return ins;}
      break;
    case newSimbolo:
      ins = New();
    {if (true) return ins;}
      break;
    case delete:
      ins = Delete();
    {if (true) return ins;}
      break;
    case seq:
      ins = Compuesta();
    {if (true) return ins;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Ins Ident() throws ParseException {
               Exp eid; Ins ins;
    eid = Expresion();
    ins = InsExp(eid);
    {if (true) return ins;}
    throw new Error("Missing return statement in function");
  }

  final public Ins InsExp(Exp eid) throws ParseException {
                       Ins ins;
    switch (jj_nt.kind) {
    case asignacion:
      ins = Asig(eid);
    {if (true) return ins;}
      break;
    case parentesisApertura:
      ins = Invoc(eid);
    {if (true) return ins;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Ins Asig(Exp ei) throws ParseException {
                    Token asig; Exp ed;
    asig = jj_consume_token(asignacion);
    ed = Expresion();
    jj_consume_token(puntoComa);
    {if (true) return new Asig(ei, ed, new Nodo(asig.beginLine, asig.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Ins Invoc(Exp eid) throws ParseException {
                      Token parentesis; List<Exp> preal;
    parentesis = jj_consume_token(parentesisApertura);
    preal = PReales();
    jj_consume_token(parentesisCierre);
    jj_consume_token(puntoComa);
    {if (true) return new Invoc(eid, preal, new Nodo(parentesis.beginLine, parentesis.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Ins Condicional() throws ParseException {
  Token cond; Exp exp; Token e = null; Ins ins; List<Ins> lins = new ArrayList<Ins>(), lins2 = new ArrayList<Ins>();
    cond = jj_consume_token(ifSimbolo);
    exp = Expresion();
    jj_consume_token(then);
    label_5:
    while (true) {
      switch (jj_nt.kind) {
      case ifSimbolo:
      case whileSimbolo:
      case read:
      case write:
      case nl:
      case newSimbolo:
      case delete:
      case seq:
      case booleano:
      case nulo:
      case resta:
      case not:
      case parentesisApertura:
      case entero:
      case real:
      case identificador:
      case cadena:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_5;
      }
      ins = Ins();
                                                       lins.add(ins);
    }
    switch (jj_nt.kind) {
    case elseSimbolo:
      e = jj_consume_token(elseSimbolo);
      label_6:
      while (true) {
        switch (jj_nt.kind) {
        case ifSimbolo:
        case whileSimbolo:
        case read:
        case write:
        case nl:
        case newSimbolo:
        case delete:
        case seq:
        case booleano:
        case nulo:
        case resta:
        case not:
        case parentesisApertura:
        case entero:
        case real:
        case identificador:
        case cadena:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
        ins = Ins();
                                lins2.add(ins);
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    jj_consume_token(end);
    switch (jj_nt.kind) {
    case puntoComa:
      jj_consume_token(puntoComa);
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    List<Ins> linsInmutable = Collections.unmodifiableList(lins);
    Nodo nodo = new Nodo(cond.beginLine, cond.beginColumn);

    {if (true) return (e == null)? new IfThen(exp, linsInmutable, nodo):
      new IfThenElse(exp, linsInmutable, Collections.unmodifiableList(lins2), nodo);}
    throw new Error("Missing return statement in function");
  }

  final public Ins While() throws ParseException {
               Token wh; Exp exp; List<Ins> lins = new ArrayList<Ins>(); Ins ins;
    wh = jj_consume_token(whileSimbolo);
    exp = Expresion();
    jj_consume_token(doSimbolo);
    label_7:
    while (true) {
      switch (jj_nt.kind) {
      case ifSimbolo:
      case whileSimbolo:
      case read:
      case write:
      case nl:
      case newSimbolo:
      case delete:
      case seq:
      case booleano:
      case nulo:
      case resta:
      case not:
      case parentesisApertura:
      case entero:
      case real:
      case identificador:
      case cadena:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_7;
      }
      ins = Ins();
                                                             lins.add(ins);
    }
    jj_consume_token(end);
    switch (jj_nt.kind) {
    case puntoComa:
      jj_consume_token(puntoComa);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    Nodo nodo = new Nodo(wh.beginLine, wh.beginColumn);
    {if (true) return new While(exp, Collections.unmodifiableList(lins), nodo);}
    throw new Error("Missing return statement in function");
  }

  final public Ins Compuesta() throws ParseException {
                   Token s; List<Dec> ldec = new ArrayList<Dec>(); List<Ins> lins = new ArrayList<Ins>();
    s = jj_consume_token(seq);
    ldec = SeccionDecs();
    lins = SeccionIns();
    switch (jj_nt.kind) {
    case puntoComa:
      jj_consume_token(puntoComa);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    {if (true) return new Seq(ldec, lins, new Nodo(s.beginLine, s.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Ins Lectura() throws ParseException {
                 Token r; Exp exp;
    r = jj_consume_token(read);
    exp = Expresion();
    jj_consume_token(puntoComa);
    {if (true) return new Read(exp, new Nodo(r.beginLine, r.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Ins Escritura() throws ParseException {
                   Token w; Exp exp;
    w = jj_consume_token(write);
    exp = Expresion();
    jj_consume_token(puntoComa);
    {if (true) return new Write(exp, new Nodo(w.beginLine, w.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Ins NewLine() throws ParseException {
                 Token n;
    n = jj_consume_token(nl);
    jj_consume_token(puntoComa);
                                                   {if (true) return new NewLine(new Nodo(n.beginLine, n.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Ins New() throws ParseException {
             Token n; Exp exp;
    n = jj_consume_token(newSimbolo);
    exp = Expresion();
    jj_consume_token(puntoComa);
    {if (true) return new New(exp, new Nodo(n.beginLine, n.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Ins Delete() throws ParseException {
                Token d; Exp exp;
    d = jj_consume_token(delete);
    exp = Expresion();
    jj_consume_token(puntoComa);
    {if (true) return new Delete(exp, new Nodo(d.beginLine, d.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public List<Exp> PReales() throws ParseException {
                       List<Exp> lexp = new ArrayList<Exp>(); Exp preal;
    switch (jj_nt.kind) {
    case booleano:
    case nulo:
    case resta:
    case not:
    case parentesisApertura:
    case entero:
    case real:
    case identificador:
    case cadena:
      preal = PReal();
                   lexp.add(preal);
      label_8:
      while (true) {
        switch (jj_nt.kind) {
        case coma:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_8;
        }
        jj_consume_token(coma);
        preal = PReal();
                                                              lexp.add(preal);
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    {if (true) return Collections.unmodifiableList(lexp);}
    throw new Error("Missing return statement in function");
  }

  final public Exp PReal() throws ParseException {
               Exp exp;
    exp = Expresion();
                                              {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp Expresion() throws ParseException {
                   Exp exp;
    exp = ExpNivel0();
                                                  {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpNivel0() throws ParseException {
                   Exp exp;
    exp = ExpNivel1();
    switch (jj_nt.kind) {
    case opRelacional:
      exp = OpNivel0(exp);
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp OpNivel0(Exp op1) throws ParseException {
                         Exp op2; Token op;
    op = jj_consume_token(opRelacional);
    op2 = ExpNivel1();
    Nodo nodo = new Nodo(op.beginLine, op.beginColumn);

    String str = op.image;
    if (str.equals("=="))
      {if (true) return new Eq(op1, op2, nodo);}
    else if (str.equals("!="))
      {if (true) return new Ne(op1, op2, nodo);}
    else if (str.equals("<="))
      {if (true) return new Le(op1, op2, nodo);}
    else if (str.equals(">="))
      {if (true) return new Ge(op1, op2, nodo);}
    else if (str.equals("<"))
      {if (true) return new Lt(op1, op2, nodo);}
    else if (str.equals(">"))
      {if (true) return new Gt(op1, op2, nodo);}
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpNivel1() throws ParseException {
                   Exp op1; Token op; Exp op2;
    op1 = Suma();
    label_9:
    while (true) {
      switch (jj_nt.kind) {
      case resta:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_9;
      }
      op = jj_consume_token(resta);
      op2 = ExpNivel2();
    op1 = new Resta(op1, op2, new Nodo(op.beginLine, op.beginColumn)); {if (true) return op1;}
    }
    {if (true) return op1;}
    throw new Error("Missing return statement in function");
  }

  final public Exp Suma() throws ParseException {
              Exp op1; Token op = null; Exp op2 = null;
    op1 = ExpNivel2();
    switch (jj_nt.kind) {
    case suma:
      op = jj_consume_token(suma);
      op2 = ExpNivel2();
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    {if (true) return (op == null)? op1: new Suma(op1, op2, new Nodo(op.beginLine, op.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpNivel2() throws ParseException {
                   Exp exp;
    exp = ExpNivel3();
    switch (jj_nt.kind) {
    case and:
    case or:
      exp = OpNivel2(exp);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp OpNivel2(Exp op1) throws ParseException {
                         Exp exp;
    switch (jj_nt.kind) {
    case and:
      exp = And(op1);
    {if (true) return exp;}
      break;
    case or:
      exp = Or(op1);
    {if (true) return exp;}
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp And(Exp op1) throws ParseException {
                    Token op; Exp op2;
    op = jj_consume_token(and);
    op2 = ExpNivel3();
    {if (true) return new And(op1, op2, new Nodo(op.beginLine, op.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Exp Or(Exp op1) throws ParseException {
                   Token op; Exp op2;
    op = jj_consume_token(or);
    op2 = ExpNivel2();
    {if (true) return new Or(op1, op2, new Nodo(op.beginLine, op.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpNivel3() throws ParseException {
                   Exp exp;
    exp = ExpNivel4();
    label_10:
    while (true) {
      switch (jj_nt.kind) {
      case mul:
      case div:
      case mod:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_10;
      }
      exp = ExpBinaria3(exp);
    }
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpBinaria3(Exp op1) throws ParseException {
                            Token op; Exp op2;
    switch (jj_nt.kind) {
    case mul:
      op = jj_consume_token(mul);
      op2 = ExpNivel4();
    {if (true) return op1 = new Mul(op1, op2, new Nodo(op.beginLine, op.beginColumn));}
      break;
    case div:
      op = jj_consume_token(div);
      op2 = ExpNivel4();
    {if (true) return op1 = new Div(op1, op2, new Nodo(op.beginLine, op.beginColumn));}
      break;
    case mod:
      op = jj_consume_token(mod);
      op2 = ExpNivel4();
    {if (true) return op1 = new Mod(op1, op2, new Nodo(op.beginLine, op.beginColumn));}
    {if (true) return op1;}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpNivel4() throws ParseException {
                   Exp exp;
    switch (jj_nt.kind) {
    case resta:
    case not:
      exp = ExpUnaria4();
    {if (true) return exp;}
      break;
    case booleano:
    case nulo:
    case parentesisApertura:
    case entero:
    case real:
    case identificador:
    case cadena:
      exp = ExpNivel5();
    {if (true) return exp;}
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpUnaria4() throws ParseException {
                    Token op; Exp op1;
    switch (jj_nt.kind) {
    case resta:
      op = jj_consume_token(resta);
      op1 = ExpNivel4();
    {if (true) return new Neg(op1, new Nodo(op.beginLine, op.beginColumn));}
      break;
    case not:
      op = jj_consume_token(not);
      op1 = ExpNivel4();
    {if (true) return new Not(op1, new Nodo(op.beginLine, op.beginColumn));}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpNivel5() throws ParseException {
                   Exp exp;
    exp = ExpNoPosfija();
    label_11:
    while (true) {
      switch (jj_nt.kind) {
      case puntero:
      case corcheteApertura:
      case punto:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_11;
      }
      exp = ExpPosfija(exp);
    }
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpPosfija(Exp base) throws ParseException {
                            Exp exp;
    switch (jj_nt.kind) {
    case corcheteApertura:
      exp = Indx(base);
    {if (true) return exp;}
      break;
    case punto:
      exp = Acc(base);
    {if (true) return exp;}
      break;
    case puntero:
      exp = Indir(base);
    {if (true) return exp;}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpNoPosfija() throws ParseException {
                      Exp exp;
    switch (jj_nt.kind) {
    case parentesisApertura:
      exp = ExpParentizada();
    {if (true) return exp;}
      break;
    case booleano:
    case nulo:
    case entero:
    case real:
    case identificador:
    case cadena:
      exp = ExpBasica();
    {if (true) return exp;}
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpParentizada() throws ParseException {
                        Exp exp;
    jj_consume_token(parentesisApertura);
    exp = ExpNivel0();
    jj_consume_token(parentesisCierre);
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp ExpBasica() throws ParseException {
                   Token lit; String str;
    switch (jj_nt.kind) {
    case entero:
      lit = jj_consume_token(entero);
                 {if (true) return new Entero(lit.image, new Nodo(lit.beginLine, lit.beginColumn));}
      break;
    case real:
      lit = jj_consume_token(real);
                 {if (true) return new Decimal(lit.image, new Nodo(lit.beginLine, lit.beginColumn));}
      break;
    case cadena:
      lit = jj_consume_token(cadena);
    str = lit.image;
    {if (true) return new Cadena(str.substring(1, str.length() - 1), new Nodo(lit.beginLine, lit.beginColumn));}
      break;
    case identificador:
      lit = jj_consume_token(identificador);
                          {if (true) return new Ident(lit.image, new Nodo(lit.beginLine, lit.beginColumn));}
      break;
    case booleano:
      lit = jj_consume_token(booleano);
    str = lit.image;
    Nodo nodo = new Nodo(lit.beginLine, lit.beginColumn);

    if (str.equals("true"))
      {if (true) return new True(nodo);}
    else if (str.equals("false"))
      {if (true) return new False(nodo);}
      break;
    case nulo:
      lit = jj_consume_token(nulo);
                 {if (true) return new Nulo(new Nodo(lit.beginLine, lit.beginColumn));}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp Indx(Exp ei) throws ParseException {
                    Token corchete; Exp eid;
    corchete = jj_consume_token(corcheteApertura);
    eid = Expresion();
    jj_consume_token(corcheteCierre);
    {if (true) return new Indx(ei, eid, new Nodo(corchete.beginLine, corchete.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Exp Acc(Exp reg) throws ParseException {
                    Token op; Token id;
    op = jj_consume_token(punto);
    id = jj_consume_token(identificador);
    {if (true) return new Acc(reg, id.image, new Nodo(op.beginLine, op.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  final public Exp Indir(Exp et) throws ParseException {
                     Token op;
    op = jj_consume_token(puntero);
    {if (true) return new Indir(et, new Nodo(op.beginLine, op.beginColumn));}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public AnalizadorSintacticoTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_gen;
  final private int[] jj_la1 = new int[32];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x70,0x4cfd2000,0x70,0x0,0x10,0x10,0xe80,0x0,0x4cfd2000,0x1000,0x4cfd2000,0x4cfd2000,0x8000,0x0,0x4cfd2000,0x0,0x0,0x0,0x4c000000,0x10000000,0x40000000,0x20000000,0x0,0x0,0x80000000,0x80000000,0x4c000000,0x40000000,0x800,0x800,0xc000000,0xc000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x330030,0x0,0x400,0x100000,0x0,0x100000,0x100000,0x330030,0x20,0x330030,0x330030,0x0,0x200,0x330030,0x200,0x200,0x400,0x330030,0x0,0x0,0x0,0xc,0xc,0x3,0x3,0x330030,0x10,0x1080,0x1080,0x330020,0x330000,};
   }

  /** Constructor with InputStream. */
  public AnalizadorSintactico(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public AnalizadorSintactico(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AnalizadorSintacticoTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public AnalizadorSintactico(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AnalizadorSintacticoTokenManager(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public AnalizadorSintactico(AnalizadorSintacticoTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(AnalizadorSintacticoTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[55];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 32; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 55; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

                                                         }
